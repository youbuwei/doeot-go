package main

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
)

type endpointInfo struct {
	StructName  string
	MethodName  string
	RouteMethod string
	RoutePath   string
	RPCMethod   string
	Auth        string
	Tags        []string
}

func main() {
	module := flag.String("module", "user", "business module name, e.g. user, order")
	flag.Parse()

	// 1. 找到仓库根目录（有 go.mod）
	root, err := findRepoRoot()
	if err != nil {
		log.Fatalf("bizgen: %v", err)
	}

	// 2. 读 go.mod 的 module 路径
	modPath, err := detectModulePath(root)
	if err != nil {
		log.Fatalf("bizgen: %v", err)
	}

	endpointDir := filepath.Join(root, "internal", *module, "interfaces", "endpoint")
	files, err := filepath.Glob(filepath.Join(endpointDir, "*.go"))
	if err != nil {
		log.Fatalf("bizgen: glob %s: %v", endpointDir, err)
	}
	if len(files) == 0 {
		log.Printf("bizgen: no endpoint files found in %s", endpointDir)
		return
	}

	fset := token.NewFileSet()
	var endpoints []endpointInfo

	for _, path := range files {
		f, err := parser.ParseFile(fset, path, nil, parser.ParseComments)
		if err != nil {
			log.Fatalf("bizgen: parse %s: %v", path, err)
		}
		for _, decl := range f.Decls {
			fn, ok := decl.(*ast.FuncDecl)
			if !ok || fn.Recv == nil || len(fn.Recv.List) == 0 {
				continue
			}

			// 提取 receiver 类型名：*UserEndpoint / *OrderEndpoint 等
			var recvType string
			if star, ok := fn.Recv.List[0].Type.(*ast.StarExpr); ok {
				if ident, ok := star.X.(*ast.Ident); ok {
					recvType = ident.Name
				}
			}
			if recvType == "" {
				continue
			}

			info := endpointInfo{
				StructName: recvType,
				MethodName: fn.Name.Name,
			}

			if fn.Doc != nil {
				for _, c := range fn.Doc.List {
					text := strings.TrimSpace(strings.TrimPrefix(c.Text, "//"))
					switch {
					case strings.HasPrefix(text, "@Route"):
						// @Route  GET /users/:id
						parts := strings.Fields(text)
						if len(parts) >= 3 {
							info.RouteMethod = parts[1]
							info.RoutePath = parts[2]
						}
					case strings.HasPrefix(text, "@RPC"):
						// @RPC    User.Get
						parts := strings.Fields(text)
						if len(parts) >= 2 {
							info.RPCMethod = parts[1]
						}
					case strings.HasPrefix(text, "@Auth"):
						parts := strings.Fields(text)
						if len(parts) >= 2 {
							info.Auth = parts[1]
						}
					case strings.HasPrefix(text, "@Tags"):
						parts := strings.Fields(text)
						if len(parts) >= 2 {
							info.Tags = parts[1:]
						}
					}
				}
			}

			if info.RouteMethod != "" || info.RPCMethod != "" {
				endpoints = append(endpoints, info)
			}
		}
	}

	if len(endpoints) == 0 {
		log.Printf("bizgen: no annotated endpoints found under %s", endpointDir)
		return
	}

	if err := generateHTTP(root, *module, modPath, endpoints); err != nil {
		log.Fatalf("bizgen: generate http: %v", err)
	}
	if err := generateRPC(root, *module, modPath, endpoints); err != nil {
		log.Fatalf("bizgen: generate rpc: %v", err)
	}
}

// 向上找 go.mod 作为仓库根目录
func findRepoRoot() (string, error) {
	dir, err := os.Getwd()
	if err != nil {
		return "", fmt.Errorf("getwd: %w", err)
	}
	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			return "", fmt.Errorf("go.mod not found starting from %s", dir)
		}
		dir = parent
	}
}

// 从 root/go.mod 中解析 module 路径
func detectModulePath(root string) (string, error) {
	data, err := os.ReadFile(filepath.Join(root, "go.mod"))
	if err != nil {
		return "", err
	}
	lines := strings.Split(string(data), "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "module ") {
			return strings.TrimSpace(strings.TrimPrefix(line, "module ")), nil
		}
	}
	return "", fmt.Errorf("module path not found in go.mod")
}

func generateHTTP(root, module, modPath string, eps []endpointInfo) error {
	httpDir := filepath.Join(root, "internal", module, "interfaces", "http")
	if err := os.MkdirAll(httpDir, 0o755); err != nil {
		return err
	}
	path := filepath.Join(httpDir, "zz_routes_gen.go")
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	endpointType := "Endpoint"
	if len(eps) > 0 && eps[0].StructName != "" {
		endpointType = eps[0].StructName
	}

	fmt.Fprintln(f, "// Code generated by bizgen; DO NOT EDIT.")
	fmt.Fprintln(f, "package http")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "import (")
	fmt.Fprintf(f, "\t\"%s/internal/%s/interfaces/endpoint\"\n", modPath, module)
	fmt.Fprintf(f, "\t\"%s/pkg/biz\"\n", modPath)
	fmt.Fprintf(f, "\t\"%s/pkg/errs\"\n", modPath)
	fmt.Fprintf(f, "\t\"%s/pkg/validate\"\n", modPath)
	fmt.Fprintln(f, ")")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "// RegisterRoutes is generated from endpoint annotations.")
	fmt.Fprintf(f, "func RegisterRoutes(r biz.Router, ep *endpoint.%s) {\n", endpointType)

	for _, e := range eps {
		if e.RouteMethod == "" || e.RoutePath == "" {
			continue
		}
		method := strings.ToUpper(e.RouteMethod)
		if method != "GET" && method != "POST" && method != "PUT" && method != "DELETE" {
			continue
		}

		fmt.Fprintf(f, "\tr.%s(\"%s\", func(ctx biz.Context) error {\n", method, e.RoutePath)
		fmt.Fprintf(f, "\t\tvar req endpoint.%sReq\n", e.MethodName)
		fmt.Fprintln(f, "\t\tif err := ctx.Bind(&req); err != nil {")
		fmt.Fprintln(f, "\t\t\treturn ctx.Result(nil, errs.BadRequest(\"invalid request\").WithCause(err))")
		fmt.Fprintln(f, "\t\t}")
		fmt.Fprintln(f, "\t\tif err := validate.Struct(&req); err != nil {")
		fmt.Fprintln(f, "\t\t\treturn ctx.Result(nil, err)")
		fmt.Fprintln(f, "\t\t}")
		fmt.Fprintf(f, "\t\tresp, err := ep.%s(ctx, &req)\n", e.MethodName)
		fmt.Fprintln(f, "\t\treturn ctx.Result(resp, err)")

		bizTag := strings.ToLower(module + "." + strings.ToLower(e.MethodName))

		// 组装可选项：WithAuth / WithTags / WithBizTag
		opts := []string{}
		if e.Auth != "" {
			opts = append(opts, fmt.Sprintf("biz.WithAuth(%q)", e.Auth))
		}
		if len(e.Tags) > 0 {
			var qt []string
			for _, t := range e.Tags {
				qt = append(qt, fmt.Sprintf("%q", t))
			}
			opts = append(opts, fmt.Sprintf("biz.WithTags(%s)", strings.Join(qt, ", ")))
		}
		opts = append(opts, fmt.Sprintf("biz.WithBizTag(%q)", bizTag))

		fmt.Fprintf(f, "\t}, %s)\n", strings.Join(opts, ", "))
	}

	fmt.Fprintln(f, "}")
	return nil
}

func generateRPC(root, module, modPath string, eps []endpointInfo) error {
	rpcDir := filepath.Join(root, "internal", module, "interfaces", "rpc")
	if err := os.MkdirAll(rpcDir, 0o755); err != nil {
		return err
	}
	path := filepath.Join(rpcDir, "zz_rpc_gen.go")
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	endpointType := "Endpoint"
	if len(eps) > 0 && eps[0].StructName != "" {
		endpointType = eps[0].StructName
	}

	fmt.Fprintln(f, "// Code generated by bizgen; DO NOT EDIT.")
	fmt.Fprintln(f, "package rpc")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "import (")
	fmt.Fprintln(f, "\t\"encoding/json\"")
	fmt.Fprintf(f, "\t\"%s/internal/%s/interfaces/endpoint\"\n", modPath, module)
	fmt.Fprintf(f, "\t\"%s/pkg/biz\"\n", modPath)
	fmt.Fprintf(f, "\t\"%s/pkg/errs\"\n", modPath)
	fmt.Fprintf(f, "\t\"%s/pkg/validate\"\n", modPath)
	fmt.Fprintln(f, ")")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "// RegisterRPC is generated from endpoint annotations.")
	fmt.Fprintf(f, "func RegisterRPC(r biz.RPCRouter, ep *endpoint.%s) {\n", endpointType)

	for _, e := range eps {
		if e.RPCMethod == "" {
			continue
		}
		bizTag := strings.ToLower(module + "." + strings.ToLower(e.MethodName))

		fmt.Fprintf(f, "\tr.Handle(%q, func(ctx biz.Context, raw json.RawMessage) (any, error) {\n", e.RPCMethod)
		fmt.Fprintf(f, "\t\tvar req endpoint.%sReq\n", e.MethodName)
		fmt.Fprintln(f, "\t\tif err := json.Unmarshal(raw, &req); err != nil {")
		fmt.Fprintln(f, "\t\t\treturn nil, errs.BadRequest(\"invalid params\").WithCause(err)")
		fmt.Fprintln(f, "\t\t}")
		fmt.Fprintln(f, "\t\tif err := validate.Struct(&req); err != nil {")
		fmt.Fprintln(f, "\t\t\treturn nil, err")
		fmt.Fprintln(f, "\t\t}")
		fmt.Fprintf(f, "\t\treturn ep.%s(ctx, &req)\n", e.MethodName)
		fmt.Fprintf(f, "\t}, biz.WithBizTag(%q))\n", bizTag)
	}

	fmt.Fprintln(f, "}")
	return nil
}
