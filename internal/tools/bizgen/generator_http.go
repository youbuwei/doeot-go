package bizgen

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// 生成 HTTP 路由包装代码。
func generateHTTP(res *scanResult, module string) error {
	httpDir := filepath.Join(res.RootDir, "internal", module, "interfaces", "http")
	if err := os.MkdirAll(httpDir, 0o755); err != nil {
		return err
	}
	path := filepath.Join(httpDir, "zz_routes_gen.go")
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	eps := res.Endpoints
	if len(eps) == 0 {
		return nil
	}

	endpointType := "Endpoint"
	if eps[0].StructName != "" {
		endpointType = eps[0].StructName
	}

	fmt.Fprintln(f, "// Code generated by bizgen; DO NOT EDIT.")
	fmt.Fprintln(f, "package http")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "import (")
	fmt.Fprintf(f, "\t\"%s/internal/%s/interfaces/endpoint\"\n", res.ModPath, module)
	fmt.Fprintf(f, "\t\"%s/pkg/biz\"\n", res.ModPath)
	fmt.Fprintf(f, "\t\"%s/pkg/errs\"\n", res.ModPath)
	fmt.Fprintf(f, "\t\"%s/pkg/validate\"\n", res.ModPath)
	fmt.Fprintln(f, ")")
	fmt.Fprintln(f)
	fmt.Fprintln(f, "// RegisterRoutes is generated from endpoint annotations.")
	fmt.Fprintf(f, "func RegisterRoutes(r biz.Router, ep *endpoint.%s) {\n", endpointType)

	for _, e := range eps {
		if e.RouteMethod == "" || e.RoutePath == "" {
			continue
		}
		method := strings.ToUpper(e.RouteMethod)
		switch method {
		case "GET", "POST", "PUT", "DELETE":
		default:
			continue
		}

		fmt.Fprintf(f, "\tr.%s(%q, func(ctx biz.Context) error {\n", method, e.RoutePath)
		fmt.Fprintf(f, "\t\tvar req endpoint.%sReq\n", e.MethodName)
		fmt.Fprintln(f, "\t\tif err := ctx.Bind(&req); err != nil {")
		fmt.Fprintln(f, "\t\t\treturn ctx.Result(nil, errs.BadRequest(\"invalid request\").WithCause(err))")
		fmt.Fprintln(f, "\t\t}")
		fmt.Fprintln(f, "\t\tif err := validate.Struct(&req); err != nil {")
		fmt.Fprintln(f, "\t\t\treturn ctx.Result(nil, err)")
		fmt.Fprintln(f, "\t\t}")
		fmt.Fprintf(f, "\t\tresp, err := ep.%s(ctx, &req)\n", e.MethodName)
		fmt.Fprintln(f, "\t\treturn ctx.Result(resp, err)")

		bizTag := strings.ToLower(module + "." + strings.ToLower(e.MethodName))

		var opts []string
		if e.Auth != "" {
			opts = append(opts, fmt.Sprintf("biz.WithAuth(%q)", e.Auth))
		}
		if len(e.Tags) > 0 {
			quotedTags := make([]string, 0, len(e.Tags))
			for _, t := range e.Tags {
				quotedTags = append(quotedTags, fmt.Sprintf("%q", t))
			}
			opts = append(opts, fmt.Sprintf("biz.WithTags(%s)", strings.Join(quotedTags, ", ")))
		}
		opts = append(opts, fmt.Sprintf("biz.WithBizTag(%q)", bizTag))

		fmt.Fprintf(f, "\t}, %s)\n", strings.Join(opts, ", "))
	}

	fmt.Fprintln(f, "}")
	return nil
}
